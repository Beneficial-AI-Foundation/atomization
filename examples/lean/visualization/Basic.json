{
  "Atoms": [
    {
      "Atom_g_atom": {
        "identifier": "Atom_g",
        "body": "def Atom_g := 1",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_f_atom": {
        "identifier": "Atom_f",
        "body": "def Atom_f := 2",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_fg_atom": {
        "identifier": "Atom_fg",
        "body": "def Atom_fg := Atom_g + Atom_g",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_g"]
      }
    },
    {
      "Atom_f'_atom": {
        "identifier": "Atom_f'",
        "body": "def Atom_f' : 2 = 2 := rfl",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_f''_atom": {
        "identifier": "Atom_f''",
        "body": "theorem Atom_f'' : 2 = 2 := by rfl",
        "statement_type": "proof",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_f'''_atom": {
        "identifier": "Atom_f'''",
        "body": "theorem Atom_f''' : 2 = 2 := by omega",
        "statement_type": "proof",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_fib_atom": {
        "identifier": "Atom_fib",
        "body": "def Atom_fib : Nat → Nat := fun n =>\n  match n with\n  | 0 => 0\n  | 1 => 1\n  | n + 2 => Atom_fib (n + 1) + Atom_fib n",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_fib"]
      }
    },
    {
      "Atom_fibImperative_atom": {
        "identifier": "Atom_fibImperative",
        "body": "def Atom_fibImperative (n: Nat) : Nat := Id.run do\n  let mut a : Nat := 0\n  let mut b : Nat := 1\n  for _ in [0:n] do\n    let c := a + b\n    a := b\n    b := c\n  return b",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Id.run"]
      }
    },
    {
      "Atom_fib_spec_atom": {
        "identifier": "Atom_fib_spec",
        "body": "@[csimp]\ntheorem Atom_fib_spec : @Atom_fib = @Atom_fibImperative := by\n  sorry",
        "statement_type": "proof",
        "language": "Lean",
        "deps": ["Atom_fib", "Atom_fibImperative"]
      }
    },
    {
      "Atom_trivial_atom": {
        "identifier": "Atom_trivial",
        "body": "def Atom_trivial : Nat := 1",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_trivial__atom": {
        "identifier": "Atom_trivial_",
        "body": "def Atom_trivial_ : Nat := 1 + 1 - 1",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_trivial_eq_atom": {
        "identifier": "Atom_trivial_eq",
        "body": "theorem Atom_trivial_eq : Atom_trivial = Atom_trivial_ := by rfl",
        "statement_type": "proof",
        "language": "Lean",
        "deps": ["Atom_trivial", "Atom_trivial_"]
      }
    },
    {
      "Atom_even_atom": {
        "identifier": "Atom_even",
        "body": "def Atom_even : Nat → Bool\n  | 0 => true\n  | n + 1 => Atom_odd n",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_odd"]
      }
    },
    {
      "Atom_odd_atom": {
        "identifier": "Atom_odd",
        "body": "def Atom_odd : Nat → Bool\n  | 0 => false\n  | n + 1 => Atom_even n",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_even"]
      }
    },
    {
      "Atom_sumUpTo_atom": {
        "identifier": "Atom_sumUpTo",
        "body": "def Atom_sumUpTo (n : Nat) : Nat := match n with\n  | 0 => 0\n  | n+1 => n + 1 + Atom_sumUpTo n",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_sumUpTo"]
      }
    },
    {
      "Atom_fastSumUpTo_atom": {
        "identifier": "Atom_fastSumUpTo",
        "body": "def Atom_fastSumUpTo (n : Nat) : Nat := n * (n + 1) / 2",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_split_sum_atom": {
        "identifier": "Atom_split_sum",
        "body": "theorem Atom_split_sum (n : Nat) : Atom_sumUpTo (n + 1) = n + 1 + Atom_sumUpTo n := by simp [Atom_sumUpTo]",
        "statement_type": "proof",
        "language": "Lean",
        "deps": ["Atom_sumUpTo"]
      }
    },
    {
      "Atom_Test.f_atom": {
        "identifier": "Atom_Test.f",
        "body": "def f := 1",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_Test.g_atom": {
        "identifier": "Atom_Test.g",
        "body": "def g := 2",
        "statement_type": "code",
        "language": "Lean",
        "deps": []
      }
    },
    {
      "Atom_Test.h_atom": {
        "identifier": "Atom_Test.h",
        "body": "def h := f + g",
        "statement_type": "code",
        "language": "Lean",
        "deps": ["Atom_Test.f", "Atom_Test.g"]
      }
    }
  ]
} 