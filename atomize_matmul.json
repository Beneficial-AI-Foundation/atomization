{
 "code": [
           {"content": "class Zero (α : Type) where\nzero : α\n",
           "order": 0},
           {"content": "instance {α : Type} [Zero α] : OfNat α 0 where\nofNat := Zero.zero\n",
           "order": 1},
           {"content": "instance : Zero Nat where\nzero := 0\n",
           "order": 2},
           {"content": "structure Vector (α : Type) (n : Nat) where\n  data : Array α\n_pf : data.size = n\nderiving Repr,DecidableEq",
           "order": 3},
           {"content": "def Vector.get {α : Type} {n : Nat} (v : Vector α n) (i : Fin n) : α :=\n  have h : i < n := by exact i.isLt\n  have h' : n = v.data.size := v._pf.symm\n  have h'' : i < v.data.size := Nat.lt_of_lt_of_eq h h'\n  v.data[i]'h''",
           "order": 4},
           {"content": "def Vector.ofFn {α : Type} {n : Nat} (f : Fin n → α) : Vector α n :=\n  { data := Array.ofFn f, _pf := by exact Array.size_ofFn f }",
           "order": 5},
           {"content": "def Vector.foldl {α : Type} {n : Nat} {β : Type} (v : Vector α n) (f : β → α → β) (init : β) : β :=\n  v.data.foldl f init",
           "order": 6},
           {"content": "def Vector.zipWith {α : Type} {n : Nat} {β : Type} {γ : Type} (v₁ : Vector α n) (v₂ : Vector β n) (f : α → β → γ) : Vector γ n :=\n  Vector.ofFn (fun i => f (v₁.get i) (v₂.get i))",
           "order": 7},
           {"content": "def Array.allFin {n : Nat} : Array (Fin n) :=\n  Array.ofFn (fun i => i)",
           "order": 8},
           {"content": "abbrev Matrix (R C : Nat) (α : Type) := Vector (Vector α C) R",
           "order": 9},
           {"content": "instance {R C : Nat} {α : Type} [ToString α] : Repr (Matrix R C α) where\n  reprPrec m _ := Id.run do\n    let mut s := \"\"\n    for r in Array.allFin R do\n      for c in Array.allFin C do\n        s := s ++ s!\"{m.get r |>.get c} \"\n      s := s ++ \"\\n\"\n    return s",
           "order": 10},
           {"content": "def Matrix.toString [ToString α] (m : Matrix R C α) : String :=\n  s!\"{repr m}\"",
           "order": 11},
           {"content": "def a : Vector Nat 3 := Vector.ofFn (fun i => i)",
           "order": 12},
           {"content": "def Vector.sum {α : Type} {C : Nat} [Add α] [Zero α] (v : Vector α C) : α :=\n  v.foldl (· + ·) 0",
           "order": 13},
           {"content": "def Vector.dot {α : Type} {R : Nat} {β : Type} {γ : Type} [HMul α β γ] [Add γ][Zero γ] (v₁:Vector α R) (v₂ : Vector β R) : γ :=\n  v₁.zipWith v₂ (· * ·) |>.sum",
           "order": 14},
           {"content": "def scalar_multiplication {α β γ : Type} {n : Nat} [HMul α β γ]  (a : α)  (v : Vector β n) : Vector γ n := Vector.ofFn (fun i => a * v.get i)",
           "order": 15},
           {"content": "def matvec_mul {α β γ : Type} {R C : Nat} [HMul α β γ] [Add γ] [Zero γ] (m : Matrix R C α) (v : Vector β C) : Vector γ R := Vector.ofFn (fun r => (m.get r).dot v)",
           "order": 16},
           {"content": "def Matrix.ofFn {α : Type} {R C : Nat} (f : Fin R → Fin C → α) : Matrix R C α :=\n  Vector.ofFn (fun r => Vector.ofFn (fun c => f r c))",
           "order": 17},
           {"content": "def A : Matrix 3 2 Nat := Vector.ofFn (fun r => Vector.ofFn (fun c => r * c))",
           "order": 18},
           {"content": "def B : Matrix 2 3 Nat := Vector.ofFn (fun c => Vector.ofFn (fun r => c * r))",
           "order": 19},
           {"content": "def Vector.toMatrix {α : Type} {R : Nat} (vec : Vector α R) : Matrix R 1 α := Vector.ofFn (fun i => Vector.ofFn (fun _ => vec.get i))",
           "order": 20},
           {"content": "def Matrix.transpose {α : Type} {R C : Nat} (A : Matrix R C α) : Matrix C R α := Vector.ofFn (fun c => Vector.ofFn (fun r => (A.get r).get c))",
           "order": 21},
           {"content": "def Matrix.mul {α β γ: Type} {R J C : Nat} [HMul α β γ] [Add γ] [Zero γ] (A : Matrix R J α) (B : Matrix J C β) : Matrix R C γ := let B' := B.transpose; Vector.ofFn (fun r => .ofFn (fun j => (A.get r).dot (B'.get j)))",
           "order": 22},
           {"content": "def test_mul : Matrix 3 3 Nat := A.mul B",
           "order": 23}
],

 "proof": [],
 "spec": [],
 "spec+code": []}

